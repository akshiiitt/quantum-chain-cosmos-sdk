# Dilithium Integration â€“ Step 1: Proto + Codec Wiring

This document summarizes the changes introduced in Step 1 to add Dilithium key support at the Cosmos SDK level. The goal of this step is to:

- Define protobuf messages for Dilithium keys (`PubKey`, `PrivKey`).
- Generate the corresponding Go types.
- Implement minimal Go wrappers to satisfy `cryptotypes.PubKey` and `cryptotypes.PrivKey` interfaces.
- Register the new types with both the Protobuf interface registry and the Amino codec so they can be packed/unpacked in `Any` and legacy Amino contexts.

## Files Added

- `proto/cosmos/crypto/dilithium/keys.proto`
  - Declares `cosmos.crypto.dilithium.PubKey` and `cosmos.crypto.dilithium.PrivKey`.
  - Sets Amino options:
    - `amino.name` for PubKey: `tendermint/PubKeyDilithium2`
    - `amino.name` for PrivKey: `tendermint/PrivKeyDilithium2`
    - `amino.message_encoding = "key_field"` for both
  - `option go_package = "github.com/cosmos/cosmos-sdk/crypto/keys/dilithium"`.

- `crypto/keys/dilithium/dilithium.go`
  - Minimal wrappers implementing Cosmos SDK crypto interfaces:
    - `const KeyType = "dilithium2"`
    - `const PubKeyName = "tendermint/PubKeyDilithium2"`
    - `const PrivKeyName = "tendermint/PrivKeyDilithium2"`
  - Implements `Bytes()`, `Address()`, `Equals()`, and Amino marshal/unmarshal methods.
  - `Sign()` returns an error (consensus signing is handled by CometBFT, not the SDK).
  - `PrivKey.PubKey()` provides a deterministic placeholder derivation (not real Dilithium math; sufficient for interface satisfaction and tests).

## Files Generated (via `make proto-gen`)

- `crypto/keys/dilithium/keys.pb.go`
- `api/cosmos/crypto/dilithium/keys.pulsar.go`

These are generated by the repository's Docker-based proto toolchain.

## Files Modified

- `crypto/codec/proto.go`
  - Imported `github.com/cosmos/cosmos-sdk/crypto/keys/dilithium`.
  - Registered implementations:
    - `registry.RegisterImplementations(pk, &dilithium.PubKey{})`
    - `registry.RegisterImplementations(priv, &dilithium.PrivKey{})`

- `crypto/codec/amino.go`
  - Imported `github.com/cosmos/cosmos-sdk/crypto/keys/dilithium`.
  - Registered Amino types:
    - `cdc.RegisterConcrete(&dilithium.PubKey{}, dilithium.PubKeyName, nil)`
    - `cdc.RegisterConcrete(&dilithium.PrivKey{}, dilithium.PrivKeyName, nil)`

## Commands Used

- Generate protobuf files (Docker required):

```bash
make proto-gen
```

- Build all modules to validate integration:

```bash
make build
```

Both completed successfully.

## Type URLs and Identifiers

- Protobuf Any type URLs:
  - `/cosmos.crypto.dilithium.PubKey`
  - `/cosmos.crypto.dilithium.PrivKey`
- Amino names:
  - `tendermint/PubKeyDilithium2`
  - `tendermint/PrivKeyDilithium2`
- SDK key type string:
  - `dilithium2`

## Notes and Limitations (Important)

- This step wires the SDK side only. Consensus key usage is governed by CometBFT. To use Dilithium at the consensus layer, CometBFT (and its `tendermint.crypto.PublicKey` definitions) must support Dilithium.
- In this repository, `proto/tendermint/crypto/keys.proto` currently exposes only Ed25519 and Secp256k1. If you are using a PQC-enabled CometBFT fork, ensure its proto and Go types include Dilithium before attempting to use Dilithium consensus keys in genesis.
- The `PrivKey.PubKey()` derivation here is a deterministic placeholder to satisfy interfaces. It is not a cryptographic Dilithium derivation and must not be used for real security-sensitive operations.

## Next Steps (Proposed)

- Integrate Dilithium into HD key derivation (if you plan to create Dilithium keys via keyring/CLI).
- Extend keyring to allow `--key-type dilithium2` where appropriate (for app-level or validator tooling depending on your security model).
- Ensure CometBFT layer recognizes Dilithium public keys in `tendermint.crypto.PublicKey` (if targeting consensus-level Dilithium).
- Add tests covering:
  - Any packing/unpacking for Dilithium keys
  - Amino JSON encoding/decoding compatibility
  - Keyring basic flows (create/list/show) if enabled

If you need a checklist or automated verification script for subsequent steps, we can add that under `scripts/` and reference it here.
